---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jjq.
--- DateTime: 2022/8/30 15:52
--- 用户自定义cluster_sender基类
--- 只是一个简单的替代原生sender的例子，不做为标准

local skynet                = require "skynet"
local sc                    = require "skynet.socketchannel"
local socket                = require "skynet.socket"
local cluster               = require "skynet.cluster.core"
local queue                 = require "skynet.queue"

local channel       --socket channel obj
local session
local lock
local remote_node, self_hostname_pid
local root_host, root_port  --可以是对方节点，也可以是负载均衡服的地址
local sc_init_obj
local req_load_balance      --请求负载均衡
local CMD

local function resp_reader(sock)
    local sz    = socket.header(sock:read(2))
    local msg   = sock:read(sz)
    return cluster.unpackresponse(msg)	-- session, ok, data, padding
end

local function channel_creator()
    if channel then
        return true
    end

    if req_load_balance then
        local host,port,backup_list = req_load_balance(root_host, root_port)

        --有可能失败
        if not host then
            skynet.error(port)
            return false
        end

        sc_init_obj.host        = host
        sc_init_obj.port        = port
        sc_init_obj.__backup    = backup_list
    end

    session     = 1
    channel     = sc.channel(sc_init_obj)

    return channel:connect(true)
end

local function check_connection()
    if not channel then
        return lock(channel_creator)
    end

    return true
end

local command   = {}

local function req(addr, msg, sz)
    -- msg is a local pointer, cluster.packrequest will free it
    local current_session = session
    local request, new_session, padding = cluster.packrequest(addr, current_session, msg, sz)
    session = new_session

    return pcall(channel.request,channel,request,current_session,padding)
end

function command.req(addr, msg, sz)
    local ok = check_connection()

    if not ok then
        skynet.response()(false)
        return
    end

    local ok, msg = req(addr, msg, sz)

    if ok then
        if type(msg) == "table" then
            skynet.ret(cluster.concat(msg))
        else
            skynet.ret(msg)
        end
    else
        if req_load_balance then
            channel = nil
        end
        skynet.error(msg)
        skynet.response()(false)
    end
end

function command.push(addr, msg, sz)
    local ok = check_connection()

    if not ok then
        return ok
    end

    local request, new_session, padding = cluster.packpush(addr, session, msg, sz)

    if padding then	-- is multi push
        session = new_session
    end

    local ok,msg = pcall(channel.request,channel,request, nil, padding)

    if not ok and req_load_balance then
        channel = nil
    end

    return ok,msg
end

function command.connect()
    local ok = check_connection()

    skynet.ret(skynet.pack(ok))

    return ok
end

function command.changenode(host, port)
    --host==false等于关闭连接
    if not host then
        if not channel then
            skynet.ret(skynet.pack(nil))
            return
        end

        skynet.error(string.format("Close cluster sender %s:%d", channel.__host, channel.__port))
        channel:close()

        if req_load_balance then
            channel = nil
        end
    else
        port = tonumber(port)

        if root_host == host and root_port == port then
            skynet.ret(skynet.pack(nil))
            return
        end

        root_host, root_port = host, port

        if not channel then
            skynet.ret(skynet.pack(nil))
            return
        end

        if req_load_balance then
            channel:close()
            channel = nil
        else
            sc_init_obj.host,sc_init_obj.port        = root_host, root_port

            channel:changehost(root_host, root_port)

            --下次调用再连接
            --channel:connect(true)
        end
    end

    skynet.ret(skynet.pack(nil))
end

--临时性关闭socket,可以重连
function command.close()
    if not channel then
        skynet.ret(skynet.pack(nil))
        return
    end

    skynet.error("close sender socket")
    channel:close()
    if req_load_balance then
        channel = nil
    end
    skynet.ret(skynet.pack(nil))
end

local M = {}

function M.start(init_obj,...)
    remote_node, self_hostname_pid, root_host, root_port = ...
    root_port           = tonumber(root_port)

    req_load_balance    = init_obj.req_load_balance

    CMD                 = init_obj.CMD or {}

    sc_init_obj = {
        host        = root_host,
        port        = root_port,
        response    = resp_reader,
        nodelay     = true,
        auth        = init_obj.auth,
        overload    = init_obj.overload,
    }

    skynet.start(function()
        lock        = queue()

        local constructor = init_obj.constructor
        if constructor then
            constructor()
        end

        skynet.dispatch("lua", function(session , source, cmd, ...)

            local f = command[cmd]

            if f then
                f(...)
                return
            end

            f = assert(CMD[cmd])
            skynet.ret(skynet.pack(f(...)))
        end)
    end)
end

function M.push(actor,...)
    check_connection()

    return command.push(actor, skynet.pack(...))
end

--第一个返回值是boolean，这样省的在调用层多写一个pcall
function M.req(actor,...)
    check_connection()

    local ok, msg = req(actor, skynet.pack(...))

    if ok then
        if type(msg) == "table" then
            return true,skynet.unpack(cluster.concat(msg))
        else
            return true,skynet.unpack(msg)
        end
    else
        if req_load_balance then
            channel = nil
        end
        skynet.error(msg)
        return ok,msg
    end
end

function M.connect()
    return check_connection()
end

return M